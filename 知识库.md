# SillyTavern 插件功能按钮开发知识库

本文档总结了在SillyTavern插件中创建自定义UI（如顶部栏）并为其添加功能按钮的核心技术和最佳实践。

## 1. 插件的基本构成

一个基础的UI插件通常由三个核心文件构成：

-   **`manifest.json`**: 插件的清单文件。它告诉SillyTavern插件的名称、作者以及需要加载的JavaScript和CSS文件。
    ```json
    {
        "display_name": "My Cool Extension",
        "js": "index.js",
        "css": "style.css"
    }
    ```
-   **`index.js`**: 插件的主要逻辑文件，负责创建UI元素、定义按钮行为和与SillyTavern核心功能交互。
-   **`style.css`**: 定义插件UI元素的样式。

## 2. 创建并注入自定义UI

在 `index.js` 中，通过标准的DOM API来创建和注入UI元素。

1.  **获取挂载点**: 首先，获取一个SillyTavern页面上稳定存在的元素作为挂载点。`#sheld` 是一个常用的选择。
    ```javascript
    const sheld = document.getElementById('sheld');
    const chat = document.getElementById('chat');
    ```
2.  **创建新元素**: 使用 `document.createElement` 创建你的UI容器（例如，一个顶部栏）。
    ```javascript
    const topBar = document.createElement('div');
    topBar.id = 'myExtensionTopBar';
    ```
3.  **注入页面**: 使用 `insertBefore` 或 `appendChild` 将你的UI容器添加到挂载点。
    ```javascript
    // 将 topBar 插入到 #sheld 内部，#chat 元素之前
    sheld.insertBefore(topBar, chat);
    ```

## 3. 动态创建功能按钮

为了代码的可维护性，推荐使用一个配置数组来动态生成所有按钮。

1.  **定义配置数组**: 创建一个数组，每个对象代表一个按钮，包含其ID、图标、提示文字和点击事件。
    ```javascript
    const icons = [
        {
            id: 'myButtonEdit',
            icon: 'fa-fw fa-solid fa-pen-to-square', // Font Awesome 图标
            position: 'right',
            title: '编辑最后回复',
            onClick: onEditClick, // 点击时调用的函数
            isHidden: false, // 可选，用于初始状态控制
        },
        // ...更多按钮
    ];
    ```
2.  **遍历并创建按钮**: 编写一个函数，遍历 `icons` 数组，为每个对象创建DOM元素并绑定事件。
    ```javascript
    function addIcons() {
        icons.forEach(icon => {
            const iconElement = document.createElement('i');
            iconElement.id = icon.id;
            iconElement.className = icon.icon;
            iconElement.title = icon.title;
            iconElement.classList.add('right_menu_button');
            if (icon.isHidden) {
                iconElement.classList.add('displayNone');
            }
            iconElement.addEventListener('click', icon.onClick);
            topBar.appendChild(iconElement);
        });
    }
    ```

## 4. 与SillyTavern核心功能交互的三种主要方式

这是实现功能的关键。

### 方式一：模拟用户点击

这是最简单直接的方法，通过代码找到页面上已有的按钮或元素并触发其 `click()` 事件。

-   **优点**: 无需了解功能的内部实现，代码简单。
-   **缺点**: 依赖于固定的HTML `id`，如果SillyTavern更新导致 `id` 变化，代码会失效。

**示例**: 触发“开始新聊天”功能。
```javascript
function onNewChatClick() {
    document.getElementById('option_start_new_chat')?.click();
}
```

### 方式二：使用全局上下文 `SillyTavern.getContext()`

SillyTavern通过 `SillyTavern.getContext()` 暴露了许多核心API，这是最推荐、最稳定的交互方式。

-   **优点**: 直接调用官方API，功能稳定，不易受UI变动影响。
-   **缺点**: 需要了解 `getContext()` 提供了哪些可用的函数。

**示例**: 使用 `/del` 命令删除消息。
```javascript
const { executeSlashCommandsWithOptions, Popup } = SillyTavern.getContext();

async function onDeleteLastReplyClick() {
    const confirm = await Popup.show.confirm('确定吗?');
    if (confirm) {
        // 删除最后一条消息
        await executeSlashCommandsWithOptions('/del 1');
    }
}
```

### 方式三：直接操作DOM元素（高级）

对于没有直接API的功能（如进入消息编辑模式），我们需要直接操作DOM。

-   **优点**: 可以实现任何用户能手动操作的功能。
-   **缺点**: 对DOM结构的依赖性极强，代码最脆弱。

**示例**: 点击最后一条AI消息的“编辑”按钮。
```javascript
const messages = document.querySelectorAll('.mes:not([is_user="true"])');
const lastMessage = messages[messages.length - 1];
const editButton = lastMessage.querySelector('.mes_button.mes_edit');
if (editButton) {
    editButton.click();
}
```

## 5. 解决异步UI更新问题（竞态条件）

**问题**: 当你通过代码触发一个UI变化（如点击“编辑”），对应的UI（如编辑框）不会立即出现，而是需要几毫秒的渲染时间。如果你的代码立即检查新UI是否存在，几乎总会失败。

**解决方案**: 使用 `MutationObserver` 来监视DOM变化。

`MutationObserver` 是一种强大的Web API，它可以在指定的DOM节点发生变化时异步执行回调函数。

**示例**: 在点击编辑按钮后，可靠地检测编辑框的出现。

```javascript
function onEditLastReplyClick() {
    // ...找到最后一条消息和编辑按钮...

    if (editButton) {
        let enteredEditMode = false;

        // 1. 创建一个观察者
        const startEditObserver = new MutationObserver((mutationsList, observer) => {
            // 检查DOM变化，看是否出现了我们等待的元素
            if (lastMessage.querySelector('textarea.mes_edit')) {
                enteredEditMode = true;
                observer.disconnect(); // 找到后立即停止观察

                // 在这里执行进入编辑模式后的逻辑
                toggleEditButtons(true);
                // ...
            }
        });

        // 2. 开始观察目标节点（这里是消息本身）
        startEditObserver.observe(lastMessage, { childList: true, subtree: true });

        // 3. 触发UI变化
        editButton.click();

        // 4. 设置一个超时后备方案，以防万一
        setTimeout(() => {
            startEditObserver.disconnect();
            if (!enteredEditMode) {
                console.error("超时：未能进入编辑模式。");
            }
        }, 2000); // 2秒超时
    }
}
```

通过这种方式，我们可以编写出响应迅速且极其可靠的、与UI交互的代码，彻底避免竞态条件问题。

## 6. 新增功能：精确的消息导航与选择性操作

在本次开发中，我们实现了更高级的功能：让用户能够精确导航到任意消息，并对选中的消息执行编辑或删除操作。

### 6.1 状态管理：跟踪当前选中消息

为了实现精确操作，我们需要维护一个状态来跟踪用户当前选中的消息。

```javascript
let currentMessageIndex = -1; // -1 表示未选中任何消息
```

### 6.2 增强的导航功能

导航功能现在可以遍历所有消息（包括用户和AI消息），而不仅仅是AI回复。

```javascript
function navigateReplies(direction) {
  const chatContainer = document.getElementById('chat');
  const messages = Array.from(chatContainer.querySelectorAll('.mes:not([is_system="true"])'));
  if (messages.length === 0) return;

  if (currentMessageIndex === -1) {
    currentMessageIndex = messages.length - 1;
    messages[currentMessageIndex].scrollIntoView({ behavior: 'smooth', block: 'start' });
    return;
  }

  // ... 导航逻辑
}
```

### 6.3 选择性操作的核心逻辑

编辑和删除功能现在会根据 `currentMessageIndex` 来决定操作的目标消息。

#### 选择性删除

```javascript
async function onDeleteLastReplyClick() {
    const chatContainer = document.getElementById('chat');
    const navMessages = Array.from(chatContainer.querySelectorAll('.mes:not([is_system="true"])'));
    const aiMessages = Array.from(chatContainer.querySelectorAll('.mes:not([is_user="true"]):not([is_system="true"])'));

    // 确定要删除的消息
    let messageToDelete;
    if (currentMessageIndex !== -1 && navMessages[currentMessageIndex]) {
        messageToDelete = navMessages[currentMessageIndex]; // 选中的消息
    } else {
        messageToDelete = aiMessages[aiMessages.length - 1]; // 默认最后一条AI消息
    }

    // 执行删除操作
    const mesId = messageToDelete.getAttribute('mesid');
    if (mesId) {
        await executeSlashCommandsWithOptions(`/del ${mesId}`);
        currentMessageIndex = -1; // 重置导航状态
    }
}
```

#### 选择性编辑

```javascript
async function onEditLastReplyClick() {
    const chatContainer = document.getElementById('chat');
    const navMessages = Array.from(chatContainer.querySelectorAll('.mes:not([is_system="true"])'));
    const aiMessages = Array.from(chatContainer.querySelectorAll('.mes:not([is_user="true"]):not([is_system="true"])'));

    // 确定要编辑的消息
    let messageToEdit;
    if (currentMessageIndex !== -1 && navMessages[currentMessageIndex]) {
        messageToEdit = navMessages[currentMessageIndex]; // 选中的消息
    } else {
        messageToEdit = aiMessages[aiMessages.length - 1]; // 默认最后一条AI消息
    }

    // 精确的编辑按钮选择器
    const editButton = messageToEdit.querySelector('.mes_button.mes_edit.fa-pencil');

    if (editButton) {
        editButton.click();

        // 使用 waitUntilCondition 稳定检测编辑状态
        const enteredEditMode = await waitUntilCondition(() => messageToEdit.querySelector('.mes_edit_buttons'), 2000);

        if (enteredEditMode) {
            // 进入编辑模式后的处理
            currentlyEditingMessage = messageToEdit;
            toggleEditButtons(true);
            
            // 监视编辑状态的结束
            editStateObserver = new MutationObserver(() => {
                if (!messageToEdit.querySelector('.mes_edit_buttons')) {
                    cleanupEditState();
                }
            });
            editStateObserver.observe(messageToEdit, { childList: true, subtree: true });
        }
    }
}
```

### 6.4 使用 waitUntilCondition 的稳定检测

我们引入了 `waitUntilCondition` 辅助函数来替代复杂的 `MutationObserver` 实现，使代码更简洁可靠。

```javascript
import { debounce, waitUntilCondition } from '../../../utils.js';

// 使用示例
const enteredEditMode = await waitUntilCondition(() => messageToEdit.querySelector('.mes_edit_buttons'), 2000);
```

### 6.5 编辑状态管理

为了正确处理编辑流程，我们需要管理编辑状态：

```javascript
let currentlyEditingMessage = null;
let editStateObserver = null;

function cleanupEditState() {
    if (editStateObserver) {
        editStateObserver.disconnect();
        editStateObserver = null;
    }
    currentlyEditingMessage = null;
    toggleEditButtons(false); // 切换回正常按钮状态
}

function toggleEditButtons(isEditing) {
    const normalButtons = ['extensionTopBarNavUp', 'extensionTopBarNavDown', 'extensionTopBarEditLastReply', 'extensionTopBarDeleteLastReply'];
    const editButtons = ['extensionTopBarConfirmEdit', 'extensionTopBarCancelEdit', 'extensionTopBarDeleteEdited'];

    if (isEditing) {
        normalButtons.forEach(id => document.getElementById(id)?.classList.add('displayNone'));
        editButtons.forEach(id => document.getElementById(id)?.classList.remove('displayNone'));
    } else {
        normalButtons.forEach(id => document.getElementById(id)?.classList.remove('displayNone'));
        editButtons.forEach(id => document.getElementById(id)?.classList.add('displayNone'));
    }
}
```

### 6.6 核心设计思路总结

1. **状态驱动**: 使用 `currentMessageIndex` 作为"书签"来跟踪用户选择
2. **条件执行**: 操作函数根据当前状态决定操作目标
3. **渐进增强**: 如果没有选中消息，则执行默认行为（操作最后一条AI消息）
4. **稳定检测**: 使用 `waitUntilCondition` 确保UI状态变化的可靠检测
5. **状态清理**: 在操作完成后及时清理编辑状态，确保界面一致性

通过这种设计模式，我们成功地将原本独立的导航和操作功能有机地结合起来，为用户提供了更直观、更强大的消息管理体验。